From 81917cc18e7f928c3369bb522a570d7f25e5f8ee Mon Sep 17 00:00:00 2001
From: Ilan Ganor <ilan@kamacode.com>
Date: Sun, 5 May 2024 05:52:46 +0300
Subject: [PATCH] whitelist usb support

---
 arch/arm64/boot/dts/freescale/imx8mp-evk.dts  |   1 +
 arch/arm64/boot/dts/freescale/usb_whitelist.h |  14 +
 drivers/usb/core/hub.c                        | 844 ++++++++----------
 drivers/usb/core/otg_whitelist.h              | 136 +++
 4 files changed, 519 insertions(+), 476 deletions(-)
 create mode 100644 arch/arm64/boot/dts/freescale/usb_whitelist.h
 create mode 100644 drivers/usb/core/otg_whitelist.h

diff --git a/arch/arm64/boot/dts/freescale/imx8mp-evk.dts b/arch/arm64/boot/dts/freescale/imx8mp-evk.dts
index e9eaa33e366b..bf07d83a0230 100644
--- a/arch/arm64/boot/dts/freescale/imx8mp-evk.dts
+++ b/arch/arm64/boot/dts/freescale/imx8mp-evk.dts
@@ -8,6 +8,7 @@
 #include <dt-bindings/usb/pd.h>
 #include "imx8mp.dtsi"
 #include "gpio_named.h"
+#include "usb_whitelist.h"
 
 / {
 	model = "NXP i.MX8MPlus EVK board";
diff --git a/arch/arm64/boot/dts/freescale/usb_whitelist.h b/arch/arm64/boot/dts/freescale/usb_whitelist.h
new file mode 100644
index 000000000000..fee095ae2b13
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/usb_whitelist.h
@@ -0,0 +1,14 @@
+/ {
+    usb_whitelist {
+        compatible = "kratos,usb-whitelist";
+        vid_pid_pairs = <
+            0x0424 0x5744 
+            0x1d6b 0x0003 
+            0x0424 0x2740
+	    0x0424 0x2744
+	    0x1d6b 0x0002
+	    0x1d6b 0x0003
+            0x1d6b 0x0002
+        >;
+    };
+};
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 2dad0641dfdc..6f2a87f124fa 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -30,25 +30,21 @@
 #include <linux/random.h>
 #include <linux/pm_qos.h>
 #include <linux/kobject.h>
-
-#include <linux/bitfield.h>
+#include <linux/of.h>
 #include <linux/uaccess.h>
 #include <asm/byteorder.h>
 
 #include "hub.h"
-#include "otg_productlist.h"
+#include "otg_whitelist.h"
 
 #define USB_VENDOR_GENESYS_LOGIC		0x05e3
 #define USB_VENDOR_SMSC				0x0424
 #define USB_PRODUCT_USB5534B			0x5534
-#define USB_VENDOR_CYPRESS			0x04b4
-#define USB_PRODUCT_CY7C65632			0x6570
 #define HUB_QUIRK_CHECK_PORT_AUTOSUSPEND	0x01
 #define HUB_QUIRK_DISABLE_AUTOSUSPEND		0x02
 
 #define USB_TP_TRANSMISSION_DELAY	40	/* ns */
 #define USB_TP_TRANSMISSION_DELAY_MAX	65535	/* ns */
-#define USB_PING_RESPONSE_TIME		400	/* ns */
 
 /* Protect struct usb_device->state and ->children members
  * Note: Both are also protected by ->dev.sem, except that ->state can
@@ -97,7 +93,7 @@ module_param(old_scheme_first, bool, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(old_scheme_first,
 		 "start with the old device initialization scheme");
 
-static bool use_both_schemes = true;
+static bool use_both_schemes = 1;
 module_param(use_both_schemes, bool, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(use_both_schemes,
 		"try the other device initialization scheme if the "
@@ -183,9 +179,8 @@ int usb_device_supports_lpm(struct usb_device *udev)
 }
 
 /*
- * Set the Maximum Exit Latency (MEL) for the host to wakup up the path from
- * U1/U2, send a PING to the device and receive a PING_RESPONSE.
- * See USB 3.1 section C.1.5.2
+ * Set the Maximum Exit Latency (MEL) for the host to initiate a transition from
+ * either U1 or U2.
  */
 static void usb_set_lpm_mel(struct usb_device *udev,
 		struct usb3_lpm_parameters *udev_lpm_params,
@@ -195,37 +190,35 @@ static void usb_set_lpm_mel(struct usb_device *udev,
 		unsigned int hub_exit_latency)
 {
 	unsigned int total_mel;
+	unsigned int device_mel;
+	unsigned int hub_mel;
 
 	/*
-	 * tMEL1. time to transition path from host to device into U0.
-	 * MEL for parent already contains the delay up to parent, so only add
-	 * the exit latency for the last link (pick the slower exit latency),
-	 * and the hub header decode latency. See USB 3.1 section C 2.2.1
-	 * Store MEL in nanoseconds
+	 * Calculate the time it takes to transition all links from the roothub
+	 * to the parent hub into U0.  The parent hub must then decode the
+	 * packet (hub header decode latency) to figure out which port it was
+	 * bound for.
+	 *
+	 * The Hub Header decode latency is expressed in 0.1us intervals (0x1
+	 * means 0.1us).  Multiply that by 100 to get nanoseconds.
 	 */
 	total_mel = hub_lpm_params->mel +
-		max(udev_exit_latency, hub_exit_latency) * 1000 +
-		hub->descriptor->u.ss.bHubHdrDecLat * 100;
-
-	/*
-	 * tMEL2. Time to submit PING packet. Sum of tTPTransmissionDelay for
-	 * each link + wHubDelay for each hub. Add only for last link.
-	 * tMEL4, the time for PING_RESPONSE to traverse upstream is similar.
-	 * Multiply by 2 to include it as well.
-	 */
-	total_mel += (__le16_to_cpu(hub->descriptor->u.ss.wHubDelay) +
-		      USB_TP_TRANSMISSION_DELAY) * 2;
+		(hub->descriptor->u.ss.bHubHdrDecLat * 100);
 
 	/*
-	 * tMEL3, tPingResponse. Time taken by device to generate PING_RESPONSE
-	 * after receiving PING. Also add 2100ns as stated in USB 3.1 C 1.5.2.4
-	 * to cover the delay if the PING_RESPONSE is queued behind a Max Packet
-	 * Size DP.
-	 * Note these delays should be added only once for the entire path, so
-	 * add them to the MEL of the device connected to the roothub.
+	 * How long will it take to transition the downstream hub's port into
+	 * U0?  The greater of either the hub exit latency or the device exit
+	 * latency.
+	 *
+	 * The BOS U1/U2 exit latencies are expressed in 1us intervals.
+	 * Multiply that by 1000 to get nanoseconds.
 	 */
-	if (!hub->hdev->parent)
-		total_mel += USB_PING_RESPONSE_TIME + 2100;
+	device_mel = udev_exit_latency * 1000;
+	hub_mel = hub_exit_latency * 1000;
+	if (device_mel > hub_mel)
+		total_mel += device_mel;
+	else
+		total_mel += hub_mel;
 
 	udev_lpm_params->mel = total_mel;
 }
@@ -734,7 +727,7 @@ static void hub_irq(struct urb *urb)
 		if ((++hub->nerrors < 10) || hub->error)
 			goto resubmit;
 		hub->error = status;
-		fallthrough;
+		/* FALL THROUGH */
 
 	/* let hub_wq handle things */
 	case 0:			/* we got data:  port status changed */
@@ -904,6 +897,28 @@ int usb_hub_clear_tt_buffer(struct urb *urb)
 }
 EXPORT_SYMBOL_GPL(usb_hub_clear_tt_buffer);
 
+
+// Global variable to store the "allow all" mode status
+static bool allow_all_usb_devices = false;
+
+// Sysfs attribute operations
+static ssize_t allow_all_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%s\n", allow_all_usb_devices ? "all" : "whitelist");
+}
+
+static ssize_t allow_all_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    if (strncmp(buf, "all", 3) == 0) {
+        allow_all_usb_devices = true;
+    } else {
+        allow_all_usb_devices = false;
+    }
+    return count;
+}
+
+static DEVICE_ATTR(allow_all, S_IWUSR | S_IRUGO, allow_all_show, allow_all_store);
+
 static void hub_power_on(struct usb_hub *hub, bool do_delay)
 {
 	int port1;
@@ -1110,10 +1125,7 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 		} else {
 			hub_power_on(hub, true);
 		}
-	/* Give some time on remote wakeup to let links to transit to U0 */
-	} else if (hub_is_superspeed(hub->hdev))
-		msleep(20);
-
+	}
  init2:
 
 	/*
@@ -1228,7 +1240,7 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 			 */
 			if (portchange || (hub_is_superspeed(hub->hdev) &&
 						port_resumed))
-				set_bit(port1, hub->event_bits);
+				set_bit(port1, hub->change_bits);
 
 		} else if (udev->persist_enabled) {
 #ifdef CONFIG_PM
@@ -1782,6 +1794,8 @@ static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 
 	desc = intf->cur_altsetting;
 	hdev = interface_to_usbdev(intf);
+    	device_create_file(&hdev->dev, &dev_attr_allow_all);
+
 
 	/*
 	 * Set default autosuspend delay as 0 to speedup bus suspend,
@@ -1844,7 +1858,7 @@ static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 		return -E2BIG;
 	}
 
-#ifdef	CONFIG_USB_OTG_DISABLE_EXTERNAL_HUB
+#ifdef	CONFIG_USB_OTG_BLACKLIST_HUB
 	if (hdev->parent) {
 		dev_warn(&intf->dev, "ignoring external hub\n");
 		return -ENODEV;
@@ -2181,8 +2195,7 @@ static void hub_disconnect_children(struct usb_device *udev)
 /**
  * usb_disconnect - disconnect a device (usbcore-internal)
  * @pdev: pointer to device being disconnected
- *
- * Context: task context, might sleep
+ * Context: !in_interrupt ()
  *
  * Something got disconnected. Get rid of it and all of its children.
  *
@@ -2414,7 +2427,7 @@ static int usb_enumerate_device(struct usb_device *udev)
 	if (err < 0)
 		return err;
 
-	if (IS_ENABLED(CONFIG_USB_OTG_PRODUCTLIST) && hcd->tpl_support &&
+	if (IS_ENABLED(CONFIG_USB_OTG_WHITELIST) && hcd->tpl_support &&
 		!is_targeted(udev)) {
 		/* Maybe it can talk to us, though we can't talk to it.
 		 * (Includes HNP test device.)
@@ -2441,8 +2454,6 @@ static void set_usb_port_removable(struct usb_device *udev)
 	u16 wHubCharacteristics;
 	bool removable = true;
 
-	dev_set_removable(&udev->dev, DEVICE_REMOVABLE_UNKNOWN);
-
 	if (!hdev)
 		return;
 
@@ -2454,11 +2465,9 @@ static void set_usb_port_removable(struct usb_device *udev)
 	 */
 	switch (hub->ports[udev->portnum - 1]->connect_type) {
 	case USB_PORT_CONNECT_TYPE_HOT_PLUG:
-		dev_set_removable(&udev->dev, DEVICE_REMOVABLE);
 		return;
 	case USB_PORT_CONNECT_TYPE_HARD_WIRED:
 	case USB_PORT_NOT_USED:
-		dev_set_removable(&udev->dev, DEVICE_FIXED);
 		return;
 	default:
 		break;
@@ -2482,13 +2491,47 @@ static void set_usb_port_removable(struct usb_device *udev)
 			removable = false;
 	}
 
-	if (removable)
-		dev_set_removable(&udev->dev, DEVICE_REMOVABLE);
-	else
-		dev_set_removable(&udev->dev, DEVICE_FIXED);
+
 
 }
 
+// Define a struct for VID/PID pairs
+struct vid_pid_pair {
+    int vid;
+    int pid;
+};
+
+static int read_vid_pid_from_dts(struct vid_pid_pair **pairs, int *size) {
+    struct device_node *node;
+    const __be32 *prop;
+    int len, i, num_pairs;
+
+    node = of_find_node_by_path("/usb_whitelist");
+    if (!node)
+        return -ENODEV;
+
+    prop = of_get_property(node, "vid_pid_pairs", &len);
+    if (!prop)
+        return -EINVAL;
+
+    num_pairs = len / sizeof(u32) / 2;
+    *pairs = kmalloc_array(num_pairs, sizeof(struct vid_pid_pair), GFP_KERNEL);
+    if (!*pairs)
+        return -ENOMEM;
+
+    for (i = 0; i < num_pairs; i++) {
+        (*pairs)[i].vid = be32_to_cpup(prop++);
+        (*pairs)[i].pid = be32_to_cpup(prop++);
+    }
+
+    *size = num_pairs;
+    return 0;
+}
+
+
+
+
+
 /**
  * usb_new_device - perform initial device setup (usbcore-internal)
  * @udev: newly addressed device (in ADDRESS state)
@@ -2512,95 +2555,128 @@ static void set_usb_port_removable(struct usb_device *udev)
  */
 int usb_new_device(struct usb_device *udev)
 {
-	int err;
-
-	if (udev->parent) {
-		/* Initialize non-root-hub device wakeup to disabled;
-		 * device (un)configuration controls wakeup capable
-		 * sysfs power/wakeup controls wakeup enabled/disabled
-		 */
-		device_init_wakeup(&udev->dev, 0);
-	}
-
-	/* Tell the runtime-PM framework the device is active */
-	pm_runtime_set_active(&udev->dev);
-	pm_runtime_get_noresume(&udev->dev);
-	pm_runtime_use_autosuspend(&udev->dev);
-	pm_runtime_enable(&udev->dev);
-
-	/* By default, forbid autosuspend for all devices.  It will be
-	 * allowed for hubs during binding.
-	 */
-	usb_disable_autosuspend(udev);
-
-	err = usb_enumerate_device(udev);	/* Read descriptors */
-	if (err < 0)
-		goto fail;
-	dev_dbg(&udev->dev, "udev %d, busnum %d, minor = %d\n",
-			udev->devnum, udev->bus->busnum,
-			(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));
-	/* export the usbdev device-node for libusb */
-	udev->dev.devt = MKDEV(USB_DEVICE_MAJOR,
-			(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));
-
-	/* Tell the world! */
-	announce_device(udev);
-
-	if (udev->serial)
-		add_device_randomness(udev->serial, strlen(udev->serial));
-	if (udev->product)
-		add_device_randomness(udev->product, strlen(udev->product));
-	if (udev->manufacturer)
-		add_device_randomness(udev->manufacturer,
-				      strlen(udev->manufacturer));
-
-	device_enable_async_suspend(&udev->dev);
-
-	/* check whether the hub or firmware marks this port as non-removable */
-	set_usb_port_removable(udev);
-
-	/* Register the device.  The device driver is responsible
-	 * for configuring the device and invoking the add-device
-	 * notifier chain (used by usbfs and possibly others).
-	 */
-	err = device_add(&udev->dev);
-	if (err) {
-		dev_err(&udev->dev, "can't device_add, error %d\n", err);
-		goto fail;
-	}
-
-	/* Create link files between child device and usb port device. */
-	if (udev->parent) {
-		struct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);
-		int port1 = udev->portnum;
-		struct usb_port	*port_dev = hub->ports[port1 - 1];
-
-		err = sysfs_create_link(&udev->dev.kobj,
-				&port_dev->dev.kobj, "port");
-		if (err)
-			goto fail;
-
-		err = sysfs_create_link(&port_dev->dev.kobj,
-				&udev->dev.kobj, "device");
-		if (err) {
-			sysfs_remove_link(&udev->dev.kobj, "port");
-			goto fail;
-		}
-
-		if (!test_and_set_bit(port1, hub->child_usage_bits))
-			pm_runtime_get_sync(&port_dev->dev);
-	}
-
-	(void) usb_create_ep_devs(&udev->dev, &udev->ep0, udev);
-	usb_mark_last_busy(udev);
-	pm_runtime_put_sync_autosuspend(&udev->dev);
-	return err;
+    struct vid_pid_pair *allowed_pairs;
+    int num_pairs;
+    int err;
+    int is_allowed = 0;
+    int i = 0;
+
+    err = read_vid_pid_from_dts(&allowed_pairs, &num_pairs);
+    if (err) {
+        dev_err(&udev->dev, "Failed to read USB whitelist from DTS\n");
+    }
+
+    if (udev->parent) {
+        /* Initialize non-root-hub device wakeup to disabled;
+         * device (un)configuration controls wakeup capable
+         * sysfs power/wakeup controls wakeup enabled/disabled
+         */
+        device_init_wakeup(&udev->dev, 0);
+    }
+
+    /* Tell the runtime-PM framework the device is active */
+    pm_runtime_set_active(&udev->dev);
+    pm_runtime_get_noresume(&udev->dev);
+    pm_runtime_use_autosuspend(&udev->dev);
+    pm_runtime_enable(&udev->dev);
+
+    /* By default, forbid autosuspend for all devices.  It will be
+     * allowed for hubs during binding.
+     */
+    usb_disable_autosuspend(udev);
+
+    err = usb_enumerate_device(udev);    // Read descriptors
+    if (err < 0)
+        goto fail;
+
+    // Whitelist check
+    for (i = 0; i < num_pairs; i++) {
+        if (udev->descriptor.idVendor == allowed_pairs[i].vid &&
+            udev->descriptor.idProduct == allowed_pairs[i].pid) {
+            is_allowed = 1;
+            break;
+        }
+    }
+
+    if (allow_all_usb_devices)
+	is_allowed = 1;
+
+    dev_info(&udev->dev, "Device VID: %04x PID: %04x attempting connection.\n",
+           udev->descriptor.idVendor, udev->descriptor.idProduct);
+
+    if (!is_allowed) {
+        dev_info(&udev->dev, "Device VID: %04x PID: %04x denied.\n", 
+               udev->descriptor.idVendor, udev->descriptor.idProduct);
+        err = -EPERM;
+        goto fail;
+    } else {
+        dev_info(&udev->dev, "Device VID: %04x PID: %04x allowed.\n", 
+               udev->descriptor.idVendor, udev->descriptor.idProduct);
+    }
+
+    kfree(allowed_pairs);
+    dev_dbg(&udev->dev, "udev %d, busnum %d, minor = %d\n",
+            udev->devnum, udev->bus->busnum,
+            (((udev->bus->busnum-1) * 128) + (udev->devnum-1)));
+    /* export the usbdev device-node for libusb */
+    udev->dev.devt = MKDEV(USB_DEVICE_MAJOR,
+            (((udev->bus->busnum-1) * 128) + (udev->devnum-1)));
+
+    /* Tell the world! */
+    announce_device(udev);
+
+    if (udev->serial)
+        add_device_randomness(udev->serial, strlen(udev->serial));
+    if (udev->product)
+        add_device_randomness(udev->product, strlen(udev->product));
+    if (udev->manufacturer)
+        add_device_randomness(udev->manufacturer,
+                              strlen(udev->manufacturer));
+
+    device_enable_async_suspend(&udev->dev);
+
+    /* check whether the hub or firmware marks this port as non-removable */
+    if (udev->parent)
+        set_usb_port_removable(udev);
+
+    /* Register the device. */
+    err = device_add(&udev->dev);
+    if (err) {
+        dev_err(&udev->dev, "can't device_add, error %d\n", err);
+        goto fail;
+    }
+
+    /* Create link files between child device and usb port device. */
+    if (udev->parent) {
+        struct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);
+        int port1 = udev->portnum;
+        struct usb_port *port_dev = hub->ports[port1 - 1];
+
+        err = sysfs_create_link(&udev->dev.kobj,
+                                &port_dev->dev.kobj, "port");
+        if (err)
+            goto fail;
+
+        err = sysfs_create_link(&port_dev->dev.kobj,
+                                &udev->dev.kobj, "device");
+        if (err) {
+            sysfs_remove_link(&udev->dev.kobj, "port");
+            goto fail;
+        }
+
+        if (!test_and_set_bit(port1, hub->child_usage_bits))
+            pm_runtime_get_sync(&port_dev->dev);
+    }
+    (void) usb_create_ep_devs(&udev->dev, &udev->ep0, udev);
+    usb_mark_last_busy(udev);
+    pm_runtime_put_sync_autosuspend(&udev->dev);
+    return 0;
 
 fail:
-	usb_set_device_state(udev, USB_STATE_NOTATTACHED);
-	pm_runtime_disable(&udev->dev);
-	pm_runtime_set_suspended(&udev->dev);
-	return err;
+    usb_set_device_state(udev, USB_STATE_NOTATTACHED);
+    pm_runtime_disable(&udev->dev);
+    pm_runtime_set_suspended(&udev->dev);
+    return err;
 }
 
 
@@ -2679,79 +2755,31 @@ int usb_authorize_device(struct usb_device *usb_dev)
 	return result;
 }
 
-/**
- * get_port_ssp_rate - Match the extended port status to SSP rate
- * @hdev: The hub device
- * @ext_portstatus: extended port status
- *
- * Match the extended port status speed id to the SuperSpeed Plus sublink speed
- * capability attributes. Base on the number of connected lanes and speed,
- * return the corresponding enum usb_ssp_rate.
+/*
+ * Return 1 if port speed is SuperSpeedPlus, 0 otherwise
+ * check it from the link protocol field of the current speed ID attribute.
+ * current speed ID is got from ext port status request. Sublink speed attribute
+ * table is returned with the hub BOS SSP device capability descriptor
  */
-static enum usb_ssp_rate get_port_ssp_rate(struct usb_device *hdev,
-					   u32 ext_portstatus)
+static int port_speed_is_ssp(struct usb_device *hdev, int speed_id)
 {
-	struct usb_ssp_cap_descriptor *ssp_cap = hdev->bos->ssp_cap;
-	u32 attr;
-	u8 speed_id;
-	u8 ssac;
-	u8 lanes;
+	int ssa_count;
+	u32 ss_attr;
 	int i;
+	struct usb_ssp_cap_descriptor *ssp_cap = hdev->bos->ssp_cap;
 
 	if (!ssp_cap)
-		goto out;
-
-	speed_id = ext_portstatus & USB_EXT_PORT_STAT_RX_SPEED_ID;
-	lanes = USB_EXT_PORT_RX_LANES(ext_portstatus) + 1;
+		return 0;
 
-	ssac = le32_to_cpu(ssp_cap->bmAttributes) &
+	ssa_count = le32_to_cpu(ssp_cap->bmAttributes) &
 		USB_SSP_SUBLINK_SPEED_ATTRIBS;
 
-	for (i = 0; i <= ssac; i++) {
-		u8 ssid;
-
-		attr = le32_to_cpu(ssp_cap->bmSublinkSpeedAttr[i]);
-		ssid = FIELD_GET(USB_SSP_SUBLINK_SPEED_SSID, attr);
-		if (speed_id == ssid) {
-			u16 mantissa;
-			u8 lse;
-			u8 type;
-
-			/*
-			 * Note: currently asymmetric lane types are only
-			 * applicable for SSIC operate in SuperSpeed protocol
-			 */
-			type = FIELD_GET(USB_SSP_SUBLINK_SPEED_ST, attr);
-			if (type == USB_SSP_SUBLINK_SPEED_ST_ASYM_RX ||
-			    type == USB_SSP_SUBLINK_SPEED_ST_ASYM_TX)
-				goto out;
-
-			if (FIELD_GET(USB_SSP_SUBLINK_SPEED_LP, attr) !=
-			    USB_SSP_SUBLINK_SPEED_LP_SSP)
-				goto out;
-
-			lse = FIELD_GET(USB_SSP_SUBLINK_SPEED_LSE, attr);
-			mantissa = FIELD_GET(USB_SSP_SUBLINK_SPEED_LSM, attr);
-
-			/* Convert to Gbps */
-			for (; lse < USB_SSP_SUBLINK_SPEED_LSE_GBPS; lse++)
-				mantissa /= 1000;
-
-			if (mantissa >= 10 && lanes == 1)
-				return USB_SSP_GEN_2x1;
-
-			if (mantissa >= 10 && lanes == 2)
-				return USB_SSP_GEN_2x2;
-
-			if (mantissa >= 5 && lanes == 2)
-				return USB_SSP_GEN_1x2;
-
-			goto out;
-		}
+	for (i = 0; i <= ssa_count; i++) {
+		ss_attr = le32_to_cpu(ssp_cap->bmSublinkSpeedAttr[i]);
+		if (speed_id == (ss_attr & USB_SSP_SUBLINK_SPEED_SSID))
+			return !!(ss_attr & USB_SSP_SUBLINK_SPEED_LP);
 	}
-
-out:
-	return USB_SSP_GEN_UNKNOWN;
+	return 0;
 }
 
 /* Returns 1 if @hub is a WUSB root hub, 0 otherwise */
@@ -2765,20 +2793,11 @@ static unsigned hub_is_wusb(struct usb_hub *hub)
 }
 
 
-#ifdef CONFIG_USB_FEW_INIT_RETRIES
-#define PORT_RESET_TRIES	2
-#define SET_ADDRESS_TRIES	1
-#define GET_DESCRIPTOR_TRIES	1
-#define GET_MAXPACKET0_TRIES	1
-#define PORT_INIT_TRIES		4
-
-#else
 #define PORT_RESET_TRIES	5
 #define SET_ADDRESS_TRIES	2
 #define GET_DESCRIPTOR_TRIES	2
-#define GET_MAXPACKET0_TRIES	3
-#define PORT_INIT_TRIES		4
-#endif	/* CONFIG_USB_FEW_INIT_RETRIES */
+#define SET_CONFIG_TRIES	(2 * (use_both_schemes + 1))
+#define USE_NEW_SCHEME(i, scheme)	((i) / 2 == (int)(scheme))
 
 #define HUB_ROOT_RESET_TIME	60	/* times are in msec */
 #define HUB_SHORT_RESET_TIME	10
@@ -2786,31 +2805,23 @@ static unsigned hub_is_wusb(struct usb_hub *hub)
 #define HUB_LONG_RESET_TIME	200
 #define HUB_RESET_TIMEOUT	800
 
+/*
+ * "New scheme" enumeration causes an extra state transition to be
+ * exposed to an xhci host and causes USB3 devices to receive control
+ * commands in the default state.  This has been seen to cause
+ * enumeration failures, so disable this enumeration scheme for USB3
+ * devices.
+ */
 static bool use_new_scheme(struct usb_device *udev, int retry,
 			   struct usb_port *port_dev)
 {
 	int old_scheme_first_port =
-		(port_dev->quirks & USB_PORT_QUIRK_OLD_SCHEME) ||
-		old_scheme_first;
+		port_dev->quirks & USB_PORT_QUIRK_OLD_SCHEME;
 
-	/*
-	 * "New scheme" enumeration causes an extra state transition to be
-	 * exposed to an xhci host and causes USB3 devices to receive control
-	 * commands in the default state.  This has been seen to cause
-	 * enumeration failures, so disable this enumeration scheme for USB3
-	 * devices.
-	 */
 	if (udev->speed >= USB_SPEED_SUPER)
 		return false;
 
-	/*
-	 * If use_both_schemes is set, use the first scheme (whichever
-	 * it is) for the larger half of the retries, then use the other
-	 * scheme.  Otherwise, use the first scheme for all the retries.
-	 */
-	if (use_both_schemes && retry >= (PORT_INIT_TRIES + 1) / 2)
-		return old_scheme_first_port;	/* Second half */
-	return !old_scheme_first_port;		/* First half or all */
+	return USE_NEW_SCHEME(retry, old_scheme_first_port || old_scheme_first);
 }
 
 /* Is a USB 3.0 port in the Inactive or Compliance Mode state?
@@ -2909,15 +2920,15 @@ static int hub_port_wait_reset(struct usb_hub *hub, int port1,
 		/* extended portstatus Rx and Tx lane count are zero based */
 		udev->rx_lanes = USB_EXT_PORT_RX_LANES(ext_portstatus) + 1;
 		udev->tx_lanes = USB_EXT_PORT_TX_LANES(ext_portstatus) + 1;
-		udev->ssp_rate = get_port_ssp_rate(hub->hdev, ext_portstatus);
 	} else {
 		udev->rx_lanes = 1;
 		udev->tx_lanes = 1;
-		udev->ssp_rate = USB_SSP_GEN_UNKNOWN;
 	}
 	if (hub_is_wusb(hub))
 		udev->speed = USB_SPEED_WIRELESS;
-	else if (udev->ssp_rate != USB_SSP_GEN_UNKNOWN)
+	else if (hub_is_superspeedplus(hub->hdev) &&
+		 port_speed_is_ssp(hub->hdev, ext_portstatus &
+				   USB_EXT_PORT_STAT_RX_SPEED_ID))
 		udev->speed = USB_SPEED_SUPER_PLUS;
 	else if (hub_is_superspeed(hub->hdev))
 		udev->speed = USB_SPEED_SUPER;
@@ -3395,26 +3406,6 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 		status = 0;
 	}
 	if (status) {
-		/* Check if the port has been suspended for the timeout case
-		 * to prevent the suspended port from incorrect handling.
-		 */
-		if (status == -ETIMEDOUT) {
-			int ret;
-			u16 portstatus, portchange;
-
-			portstatus = portchange = 0;
-			ret = hub_port_status(hub, port1, &portstatus,
-					&portchange);
-
-			dev_dbg(&port_dev->dev,
-				"suspend timeout, status %04x\n", portstatus);
-
-			if (ret == 0 && port_is_suspended(hub, portstatus)) {
-				status = 0;
-				goto suspend_done;
-			}
-		}
-
 		dev_dbg(&port_dev->dev, "can't suspend, status %d\n", status);
 
 		/* Try to enable USB3 LTM again */
@@ -3431,7 +3422,6 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 		if (!PMSG_IS_AUTO(msg))
 			status = 0;
 	} else {
- suspend_done:
 		dev_dbg(&udev->dev, "usb %ssuspend, wakeup %d\n",
 				(PMSG_IS_AUTO(msg) ? "auto-" : ""),
 				udev->do_remote_wakeup);
@@ -3636,7 +3626,7 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 	u16		portchange, portstatus;
 
 	if (!test_and_set_bit(port1, hub->child_usage_bits)) {
-		status = pm_runtime_resume_and_get(&port_dev->dev);
+		status = pm_runtime_get_sync(&port_dev->dev);
 		if (status < 0) {
 			dev_dbg(&udev->dev, "can't resume usb port, status %d\n",
 					status);
@@ -3673,6 +3663,9 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 		 * sequence.
 		 */
 		status = hub_port_status(hub, port1, &portstatus, &portchange);
+
+		/* TRSMRCY = 10 msec */
+		msleep(10);
 	}
 
  SuspendCleared:
@@ -3687,9 +3680,6 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 				usb_clear_port_feature(hub->hdev, port1,
 						USB_PORT_FEAT_C_SUSPEND);
 		}
-
-		/* TRSMRCY = 10 msec */
-		msleep(10);
 	}
 
 	if (udev->persist_enabled)
@@ -4119,47 +4109,6 @@ static int usb_set_lpm_timeout(struct usb_device *udev,
 	return 0;
 }
 
-/*
- * Don't allow device intiated U1/U2 if the system exit latency + one bus
- * interval is greater than the minimum service interval of any active
- * periodic endpoint. See USB 3.2 section 9.4.9
- */
-static bool usb_device_may_initiate_lpm(struct usb_device *udev,
-					enum usb3_link_state state)
-{
-	unsigned int sel;		/* us */
-	int i, j;
-
-	if (state == USB3_LPM_U1)
-		sel = DIV_ROUND_UP(udev->u1_params.sel, 1000);
-	else if (state == USB3_LPM_U2)
-		sel = DIV_ROUND_UP(udev->u2_params.sel, 1000);
-	else
-		return false;
-
-	for (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {
-		struct usb_interface *intf;
-		struct usb_endpoint_descriptor *desc;
-		unsigned int interval;
-
-		intf = udev->actconfig->interface[i];
-		if (!intf)
-			continue;
-
-		for (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++) {
-			desc = &intf->cur_altsetting->endpoint[j].desc;
-
-			if (usb_endpoint_xfer_int(desc) ||
-			    usb_endpoint_xfer_isoc(desc)) {
-				interval = (1 << (desc->bInterval - 1)) * 125;
-				if (sel + 125 > interval)
-					return false;
-			}
-		}
-	}
-	return true;
-}
-
 /*
  * Enable the hub-initiated U1/U2 idle timeouts, and enable device-initiated
  * U1/U2 entry.
@@ -4232,23 +4181,20 @@ static void usb_enable_link_state(struct usb_hcd *hcd, struct usb_device *udev,
 	 * U1/U2_ENABLE
 	 */
 	if (udev->actconfig &&
-	    usb_device_may_initiate_lpm(udev, state)) {
-		if (usb_set_device_initiated_lpm(udev, state, true)) {
-			/*
-			 * Request to enable device initiated U1/U2 failed,
-			 * better to turn off lpm in this case.
-			 */
-			usb_set_lpm_timeout(udev, state, 0);
-			hcd->driver->disable_usb3_lpm_timeout(hcd, udev, state);
-			return;
-		}
+	    usb_set_device_initiated_lpm(udev, state, true) == 0) {
+		if (state == USB3_LPM_U1)
+			udev->usb3_lpm_u1_enabled = 1;
+		else if (state == USB3_LPM_U2)
+			udev->usb3_lpm_u2_enabled = 1;
+	} else {
+		/* Don't request U1/U2 entry if the device
+		 * cannot transition to U1/U2.
+		 */
+		usb_set_lpm_timeout(udev, state, 0);
+		hcd->driver->disable_usb3_lpm_timeout(hcd, udev, state);
 	}
-
-	if (state == USB3_LPM_U1)
-		udev->usb3_lpm_u1_enabled = 1;
-	else if (state == USB3_LPM_U2)
-		udev->usb3_lpm_u2_enabled = 1;
 }
+
 /*
  * Disable the hub-initiated U1/U2 idle timeouts, and disable device-initiated
  * U1/U2 entry.
@@ -4687,7 +4633,6 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 	const char		*speed;
 	int			devnum = udev->devnum;
 	const char		*driver_name;
-	bool			do_new_scheme;
 
 	/* root hub ports have a slightly longer reset period
 	 * (from USB 2.0 spec, section 7.1.7.5)
@@ -4703,6 +4648,8 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 	if (oldspeed == USB_SPEED_LOW)
 		delay = HUB_LONG_RESET_TIME;
 
+	mutex_lock(hcd->address0_mutex);
+
 	/* Reset the device; full speed may morph to high speed */
 	/* FIXME a USB 2.0 device may morph into SuperSpeed on reset. */
 	retval = hub_port_reset(hub, port1, udev, delay, false);
@@ -4798,13 +4745,14 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 	 * first 8 bytes of the device descriptor to get the ep0 maxpacket
 	 * value.
 	 */
-	do_new_scheme = use_new_scheme(udev, retry_counter, port_dev);
-
 	for (retries = 0; retries < GET_DESCRIPTOR_TRIES; (++retries, msleep(100))) {
-		if (do_new_scheme) {
+		bool did_new_scheme = false;
+
+		if (use_new_scheme(udev, retry_counter, port_dev)) {
 			struct usb_device_descriptor *buf;
 			int r = 0;
 
+			did_new_scheme = true;
 			retval = hub_enable_device(udev);
 			if (retval < 0) {
 				dev_err(&udev->dev,
@@ -4824,8 +4772,7 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 			 * 255 is for WUSB devices, we actually need to use
 			 * 512 (WUSB1.0[4.8.1]).
 			 */
-			for (operations = 0; operations < GET_MAXPACKET0_TRIES;
-					++operations) {
+			for (operations = 0; operations < 3; ++operations) {
 				buf->bMaxPacketSize0 = 0;
 				r = usb_control_msg(udev, usb_rcvaddr0pipe(),
 					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
@@ -4839,7 +4786,7 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 						r = 0;
 						break;
 					}
-					fallthrough;
+					/* FALL THROUGH */
 				default:
 					if (r == 0)
 						r = -EPROTO;
@@ -4904,13 +4851,9 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 						"%s SuperSpeed%s%s USB device number %d using %s\n",
 						(udev->config) ? "reset" : "new",
 					 (udev->speed == USB_SPEED_SUPER_PLUS) ?
-							" Plus" : "",
-					 (udev->ssp_rate == USB_SSP_GEN_2x2) ?
-							" Gen 2x2" :
-					 (udev->ssp_rate == USB_SSP_GEN_2x1) ?
-							" Gen 2x1" :
-					 (udev->ssp_rate == USB_SSP_GEN_1x2) ?
-							" Gen 1x2" : "",
+							"Plus Gen 2" : " Gen 1",
+					 (udev->rx_lanes == 2 && udev->tx_lanes == 2) ?
+							"x2" : "",
 					 devnum, driver_name);
 			}
 
@@ -4919,7 +4862,11 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 			 *  - read ep0 maxpacket even for high and low speed,
 			 */
 			msleep(10);
-			if (do_new_scheme)
+			/* use_new_scheme() checks the speed which may have
+			 * changed since the initial look so we cache the result
+			 * in did_new_scheme
+			 */
+			if (did_new_scheme)
 				break;
 		}
 
@@ -5018,6 +4965,7 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 		hub_port_disable(hub, port1, 0);
 		update_devnum(udev, devnum);	/* for disconnect processing */
 	}
+	mutex_unlock(hcd->address0_mutex);
 	return retval;
 }
 
@@ -5096,91 +5044,6 @@ hub_power_remaining(struct usb_hub *hub)
 	return remaining;
 }
 
-
-static int descriptors_changed(struct usb_device *udev,
-		struct usb_device_descriptor *old_device_descriptor,
-		struct usb_host_bos *old_bos)
-{
-	int		changed = 0;
-	unsigned	index;
-	unsigned	serial_len = 0;
-	unsigned	len;
-	unsigned	old_length;
-	int		length;
-	char		*buf;
-
-	if (memcmp(&udev->descriptor, old_device_descriptor,
-			sizeof(*old_device_descriptor)) != 0)
-		return 1;
-
-	if ((old_bos && !udev->bos) || (!old_bos && udev->bos))
-		return 1;
-	if (udev->bos) {
-		len = le16_to_cpu(udev->bos->desc->wTotalLength);
-		if (len != le16_to_cpu(old_bos->desc->wTotalLength))
-			return 1;
-		if (memcmp(udev->bos->desc, old_bos->desc, len))
-			return 1;
-	}
-
-	/* Since the idVendor, idProduct, and bcdDevice values in the
-	 * device descriptor haven't changed, we will assume the
-	 * Manufacturer and Product strings haven't changed either.
-	 * But the SerialNumber string could be different (e.g., a
-	 * different flash card of the same brand).
-	 */
-	if (udev->serial)
-		serial_len = strlen(udev->serial) + 1;
-
-	len = serial_len;
-	for (index = 0; index < udev->descriptor.bNumConfigurations; index++) {
-		old_length = le16_to_cpu(udev->config[index].desc.wTotalLength);
-		len = max(len, old_length);
-	}
-
-	buf = kmalloc(len, GFP_NOIO);
-	if (!buf)
-		/* assume the worst */
-		return 1;
-
-	for (index = 0; index < udev->descriptor.bNumConfigurations; index++) {
-		old_length = le16_to_cpu(udev->config[index].desc.wTotalLength);
-		length = usb_get_descriptor(udev, USB_DT_CONFIG, index, buf,
-				old_length);
-		if (length != old_length) {
-			dev_dbg(&udev->dev, "config index %d, error %d\n",
-					index, length);
-			changed = 1;
-			break;
-		}
-		if (memcmp(buf, udev->rawdescriptors[index], old_length)
-				!= 0) {
-			dev_dbg(&udev->dev, "config index %d changed (#%d)\n",
-				index,
-				((struct usb_config_descriptor *) buf)->
-					bConfigurationValue);
-			changed = 1;
-			break;
-		}
-	}
-
-	if (!changed && serial_len) {
-		length = usb_string(udev, udev->descriptor.iSerialNumber,
-				buf, serial_len);
-		if (length + 1 != serial_len) {
-			dev_dbg(&udev->dev, "serial string error %d\n",
-					length);
-			changed = 1;
-		} else if (memcmp(buf, udev->serial, length) != 0) {
-			dev_dbg(&udev->dev, "serial string changed\n");
-			changed = 1;
-		}
-	}
-
-	kfree(buf);
-	return changed;
-}
-
 static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,
 		u16 portchange)
 {
@@ -5192,7 +5055,6 @@ static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,
 	struct usb_port *port_dev = hub->ports[port1 - 1];
 	struct usb_device *udev = port_dev->child;
 	static int unreliable_port = -1;
-	bool retry_locked;
 
 	/* Disconnect any existing devices under this port */
 	if (udev) {
@@ -5248,11 +5110,8 @@ static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,
 		unit_load = 100;
 
 	status = 0;
+	for (i = 0; i < SET_CONFIG_TRIES; i++) {
 
-	for (i = 0; i < PORT_INIT_TRIES; i++) {
-		usb_lock_port(port_dev);
-		mutex_lock(hcd->address0_mutex);
-		retry_locked = true;
 		/* reallocate for each attempt, since references
 		 * to the previous one can escape in various ways
 		 */
@@ -5260,8 +5119,6 @@ static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,
 		if (!udev) {
 			dev_err(&port_dev->dev,
 					"couldn't allocate usb_device\n");
-			mutex_unlock(hcd->address0_mutex);
-			usb_unlock_port(port_dev);
 			goto done;
 		}
 
@@ -5283,14 +5140,12 @@ static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,
 		}
 
 		/* reset (non-USB 3.0 devices) and get descriptor */
+		usb_lock_port(port_dev);
 		status = hub_port_init(hub, udev, port1, i);
+		usb_unlock_port(port_dev);
 		if (status < 0)
 			goto loop;
 
-		mutex_unlock(hcd->address0_mutex);
-		usb_unlock_port(port_dev);
-		retry_locked = false;
-
 		if (udev->quirks & USB_QUIRK_DELAY_INIT)
 			msleep(2000);
 
@@ -5383,16 +5238,12 @@ static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,
 		usb_ep0_reinit(udev);
 		release_devnum(udev);
 		hub_free_dev(udev);
-		if (retry_locked) {
-			mutex_unlock(hcd->address0_mutex);
-			usb_unlock_port(port_dev);
-		}
 		usb_put_dev(udev);
 		if ((status == -ENOTCONN) || (status == -ENOTSUPP))
 			break;
 
 		/* When halfway through our retry count, power-cycle the port */
-		if (i == (PORT_INIT_TRIES - 1) / 2) {
+		if (i == (SET_CONFIG_TRIES / 2) - 1) {
 			dev_info(&port_dev->dev, "attempt power cycle\n");
 			usb_hub_set_port_power(hdev, hub, port1, false);
 			msleep(2 * hub_power_on_good_delay(hub));
@@ -5430,9 +5281,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 {
 	struct usb_port *port_dev = hub->ports[port1 - 1];
 	struct usb_device *udev = port_dev->child;
-	struct usb_device_descriptor descriptor;
 	int status = -ENODEV;
-	int retval;
 
 	dev_dbg(&port_dev->dev, "status %04x, change %04x, %s\n", portstatus,
 			portchange, portspeed(hub, portstatus));
@@ -5453,30 +5302,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 	if ((portstatus & USB_PORT_STAT_CONNECTION) && udev &&
 			udev->state != USB_STATE_NOTATTACHED) {
 		if (portstatus & USB_PORT_STAT_ENABLE) {
-			/*
-			 * USB-3 connections are initialized automatically by
-			 * the hostcontroller hardware. Therefore check for
-			 * changed device descriptors before resuscitating the
-			 * device.
-			 */
-			descriptor = udev->descriptor;
-			retval = usb_get_device_descriptor(udev,
-					sizeof(udev->descriptor));
-			if (retval < 0) {
-				dev_dbg(&udev->dev,
-						"can't read device descriptor %d\n",
-						retval);
-			} else {
-				if (descriptors_changed(udev, &descriptor,
-						udev->bos)) {
-					dev_dbg(&udev->dev,
-							"device descriptor has changed\n");
-					/* for disconnect() calls */
-					udev->descriptor = descriptor;
-				} else {
-					status = 0; /* Nothing to do */
-				}
-			}
+			status = 0;		/* Nothing to do */
 #ifdef CONFIG_PM
 		} else if (udev->state == USB_STATE_SUSPENDED &&
 				udev->persist_enabled) {
@@ -5782,11 +5608,6 @@ static const struct usb_device_id hub_id_table[] = {
       .idProduct = USB_PRODUCT_USB5534B,
       .bInterfaceClass = USB_CLASS_HUB,
       .driver_info = HUB_QUIRK_DISABLE_AUTOSUSPEND},
-    { .match_flags = USB_DEVICE_ID_MATCH_VENDOR
-                   | USB_DEVICE_ID_MATCH_PRODUCT,
-      .idVendor = USB_VENDOR_CYPRESS,
-      .idProduct = USB_PRODUCT_CY7C65632,
-      .driver_info = HUB_QUIRK_DISABLE_AUTOSUSPEND},
     { .match_flags = USB_DEVICE_ID_MATCH_VENDOR
 			| USB_DEVICE_ID_MATCH_INT_CLASS,
       .idVendor = USB_VENDOR_GENESYS_LOGIC,
@@ -5854,6 +5675,90 @@ void usb_hub_cleanup(void)
 	usb_deregister(&hub_driver);
 } /* usb_hub_cleanup() */
 
+static int descriptors_changed(struct usb_device *udev,
+		struct usb_device_descriptor *old_device_descriptor,
+		struct usb_host_bos *old_bos)
+{
+	int		changed = 0;
+	unsigned	index;
+	unsigned	serial_len = 0;
+	unsigned	len;
+	unsigned	old_length;
+	int		length;
+	char		*buf;
+
+	if (memcmp(&udev->descriptor, old_device_descriptor,
+			sizeof(*old_device_descriptor)) != 0)
+		return 1;
+
+	if ((old_bos && !udev->bos) || (!old_bos && udev->bos))
+		return 1;
+	if (udev->bos) {
+		len = le16_to_cpu(udev->bos->desc->wTotalLength);
+		if (len != le16_to_cpu(old_bos->desc->wTotalLength))
+			return 1;
+		if (memcmp(udev->bos->desc, old_bos->desc, len))
+			return 1;
+	}
+
+	/* Since the idVendor, idProduct, and bcdDevice values in the
+	 * device descriptor haven't changed, we will assume the
+	 * Manufacturer and Product strings haven't changed either.
+	 * But the SerialNumber string could be different (e.g., a
+	 * different flash card of the same brand).
+	 */
+	if (udev->serial)
+		serial_len = strlen(udev->serial) + 1;
+
+	len = serial_len;
+	for (index = 0; index < udev->descriptor.bNumConfigurations; index++) {
+		old_length = le16_to_cpu(udev->config[index].desc.wTotalLength);
+		len = max(len, old_length);
+	}
+
+	buf = kmalloc(len, GFP_NOIO);
+	if (!buf)
+		/* assume the worst */
+		return 1;
+
+	for (index = 0; index < udev->descriptor.bNumConfigurations; index++) {
+		old_length = le16_to_cpu(udev->config[index].desc.wTotalLength);
+		length = usb_get_descriptor(udev, USB_DT_CONFIG, index, buf,
+				old_length);
+		if (length != old_length) {
+			dev_dbg(&udev->dev, "config index %d, error %d\n",
+					index, length);
+			changed = 1;
+			break;
+		}
+		if (memcmp(buf, udev->rawdescriptors[index], old_length)
+				!= 0) {
+			dev_dbg(&udev->dev, "config index %d changed (#%d)\n",
+				index,
+				((struct usb_config_descriptor *) buf)->
+					bConfigurationValue);
+			changed = 1;
+			break;
+		}
+	}
+
+	if (!changed && serial_len) {
+		length = usb_string(udev, udev->descriptor.iSerialNumber,
+				buf, serial_len);
+		if (length + 1 != serial_len) {
+			dev_dbg(&udev->dev, "serial string error %d\n",
+					length);
+			changed = 1;
+		} else if (memcmp(buf, udev->serial, length) != 0) {
+			dev_dbg(&udev->dev, "serial string changed\n");
+			changed = 1;
+		}
+	}
+
+	kfree(buf);
+	return changed;
+}
+
 /**
  * usb_reset_and_verify_device - perform a USB port reset to reinitialize a device
  * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)
@@ -5928,9 +5833,7 @@ static int usb_reset_and_verify_device(struct usb_device *udev)
 	bos = udev->bos;
 	udev->bos = NULL;
 
-	mutex_lock(hcd->address0_mutex);
-
-	for (i = 0; i < PORT_INIT_TRIES; ++i) {
+	for (i = 0; i < SET_CONFIG_TRIES; ++i) {
 
 		/* ep0 maxpacket size may change; let the HCD know about it.
 		 * Other endpoints will be handled by re-enumeration. */
@@ -5939,7 +5842,6 @@ static int usb_reset_and_verify_device(struct usb_device *udev)
 		if (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)
 			break;
 	}
-	mutex_unlock(hcd->address0_mutex);
 
 	if (ret < 0)
 		goto re_enumerate;
@@ -6044,11 +5946,6 @@ static int usb_reset_and_verify_device(struct usb_device *udev)
  * the reset is over (using their post_reset method).
  *
  * Return: The same as for usb_reset_and_verify_device().
- * However, if a reset is already in progress (for instance, if a
- * driver doesn't have pre_reset() or post_reset() callbacks, and while
- * being unbound or re-bound during the ongoing reset its disconnect()
- * or probe() routine tries to perform a second, nested reset), the
- * routine returns -EINPROGRESS.
  *
  * Note:
  * The caller must own the device lock.  For example, it's safe to use
@@ -6082,10 +5979,6 @@ int usb_reset_device(struct usb_device *udev)
 		return -EISDIR;
 	}
 
-	if (udev->reset_in_progress)
-		return -EINPROGRESS;
-	udev->reset_in_progress = 1;
-
 	port_dev = hub->ports[udev->portnum - 1];
 
 	/*
@@ -6150,7 +6043,6 @@ int usb_reset_device(struct usb_device *udev)
 
 	usb_autosuspend_device(udev);
 	memalloc_noio_restore(noio_flag);
-	udev->reset_in_progress = 0;
 	return ret;
 }
 EXPORT_SYMBOL_GPL(usb_reset_device);
diff --git a/drivers/usb/core/otg_whitelist.h b/drivers/usb/core/otg_whitelist.h
new file mode 100644
index 000000000000..1001804938b8
--- /dev/null
+++ b/drivers/usb/core/otg_whitelist.h
@@ -0,0 +1,136 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * drivers/usb/core/otg_whitelist.h
+ *
+ * Copyright (C) 2004 Texas Instruments
+ */
+
+/*
+ * This OTG and Embedded Host Whitelist is "Targeted Peripheral List".
+ * It should mostly use of USB_DEVICE() or USB_DEVICE_VER() entries..
+ *
+ * YOU _SHOULD_ CHANGE THIS LIST TO MATCH YOUR PRODUCT AND ITS TESTING!
+ */
+
+static struct usb_device_id whitelist_table[] = {
+/* Add FSL i.mx whitelist, the default list is for USB Compliance Test */
+#if defined(CONFIG_USB_EHSET_TEST_FIXTURE)	\
+	|| defined(CONFIG_USB_EHSET_TEST_FIXTURE_MODULE)
+#define TEST_SE0_NAK_PID			0x0101
+#define TEST_J_PID				0x0102
+#define TEST_K_PID				0x0103
+#define TEST_PACKET_PID				0x0104
+#define TEST_HS_HOST_PORT_SUSPEND_RESUME	0x0106
+#define TEST_SINGLE_STEP_GET_DEV_DESC		0x0107
+#define TEST_SINGLE_STEP_SET_FEATURE		0x0108
+{ USB_DEVICE(0x1a0a, TEST_SE0_NAK_PID) },
+{ USB_DEVICE(0x1a0a, TEST_J_PID) },
+{ USB_DEVICE(0x1a0a, TEST_K_PID) },
+{ USB_DEVICE(0x1a0a, TEST_PACKET_PID) },
+{ USB_DEVICE(0x1a0a, TEST_HS_HOST_PORT_SUSPEND_RESUME) },
+{ USB_DEVICE(0x1a0a, TEST_SINGLE_STEP_GET_DEV_DESC) },
+{ USB_DEVICE(0x1a0a, TEST_SINGLE_STEP_SET_FEATURE) },
+#endif
+
+#define USB_INTERFACE_CLASS_INFO(cl) \
+	.match_flags = USB_DEVICE_ID_MATCH_INT_CLASS, \
+	.bInterfaceClass = (cl)
+
+{USB_INTERFACE_CLASS_INFO(USB_CLASS_HUB) },
+#if defined(CONFIG_USB_STORAGE) || defined(CONFIG_USB_STORAGE_MODULE)
+{USB_INTERFACE_CLASS_INFO(USB_CLASS_MASS_STORAGE) },
+#endif
+#if defined(CONFIG_USB_HID) || defined(CONFIG_USB_HID_MODULE)
+{USB_INTERFACE_CLASS_INFO(USB_CLASS_HID) },
+#endif
+
+{ }	/* Terminating entry */
+};
+
+static bool match_int_class(struct usb_device_id *id, struct usb_device *udev)
+{
+	struct usb_host_config *c;
+	int num_configs, i;
+
+	/* Copy the code from generic.c */
+	c = udev->config;
+	num_configs = udev->descriptor.bNumConfigurations;
+	for (i = 0; i < num_configs; (i++, c++)) {
+		struct usb_interface_descriptor	*desc = NULL;
+
+		/* It's possible that a config has no interfaces! */
+		if (c->desc.bNumInterfaces > 0)
+			desc = &c->intf_cache[0]->altsetting->desc;
+
+		if (desc && (desc->bInterfaceClass == id->bInterfaceClass))
+			return true;
+	}
+
+	return false;
+}
+
+static int is_targeted(struct usb_device *dev)
+{
+	struct usb_device_id	*id = whitelist_table;
+
+	/* HNP test device is _never_ targeted (see OTG spec 6.6.6) */
+	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x1a0a &&
+	     le16_to_cpu(dev->descriptor.idProduct) == 0xbadd))
+		return 0;
+
+	/* OTG PET device is always targeted (see OTG 2.0 ECN 6.4.2) */
+	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x1a0a &&
+	     le16_to_cpu(dev->descriptor.idProduct) == 0x0200))
+		return 1;
+
+	/* NOTE: can't use usb_match_id() since interface caches
+	 * aren't set up yet. this is cut/paste from that code.
+	 */
+	for (id = whitelist_table; id->match_flags; id++) {
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_VENDOR) &&
+		    id->idVendor != le16_to_cpu(dev->descriptor.idVendor))
+			continue;
+
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_PRODUCT) &&
+		    id->idProduct != le16_to_cpu(dev->descriptor.idProduct))
+			continue;
+
+		/* No need to test id->bcdDevice_lo != 0, since 0 is never
+		   greater than any unsigned number. */
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_LO) &&
+		    (id->bcdDevice_lo > le16_to_cpu(dev->descriptor.bcdDevice)))
+			continue;
+
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_HI) &&
+		    (id->bcdDevice_hi < le16_to_cpu(dev->descriptor.bcdDevice)))
+			continue;
+
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_CLASS) &&
+		    (id->bDeviceClass != dev->descriptor.bDeviceClass))
+			continue;
+
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_SUBCLASS) &&
+		    (id->bDeviceSubClass != dev->descriptor.bDeviceSubClass))
+			continue;
+
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_PROTOCOL) &&
+		    (id->bDeviceProtocol != dev->descriptor.bDeviceProtocol))
+			continue;
+
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_INT_CLASS) &&
+		    (!match_int_class(id, dev)))
+			continue;
+
+		return 1;
+	}
+
+	/* add other match criteria here ... */
+
+
+	/* OTG MESSAGE: report errors here, customize to match your product */
+	dev_err(&dev->dev, "device v%04x p%04x is not supported\n",
+		le16_to_cpu(dev->descriptor.idVendor),
+		le16_to_cpu(dev->descriptor.idProduct));
+
+	return 0;
+}
-- 
2.17.1

